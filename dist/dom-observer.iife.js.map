{"version":3,"file":"dom-observer.iife.js","sources":["../src/DomParser.ts","../src/EventEmitter.ts","../src/DomObserver.ts","../src/DomCollector.ts"],"sourcesContent":["/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype ParserConfigObject = {\n    type: \"object\"\n    keys: {\n        key: string\n        value: ParserConfig\n    }[]\n}\n\ntype ParserConfigArray = {\n    type: \"array\"\n    selector: string\n    items?: ParserConfig\n}\n\ntype ParserConfigString = {\n    type: \"string\"\n    selector?: string\n}\n\ntype ParseConfigBoolean = {\n    type: \"boolean\"\n    selector: string\n}\n\ntype ParseConfigCount = {\n    type: \"count\"\n    selector: string\n}\n\ntype ParseConfigNumber = {\n    type: \"number\"\n    selector: string\n    formatter: (value: string | null, el: HTMLElement | null) => number | null\n}\n\nexport type ParserConfig =\n    | ParserConfigObject\n    | ParserConfigArray\n    | ParserConfigString\n    | ParseConfigBoolean\n    | ParseConfigNumber\n    | ParseConfigCount\n\nexport type ParseDomResult =\n    | string\n    | null\n    | boolean\n    | number\n    | Array<ParseDomResult>\n    | {\n        [key: string]: ParseDomResult\n    }\n\n/**\n * Parse a specific structure from the DOM recursively\n * @param  config - configuration object that describes the type of the resulting object and how to get it from the DOM\n * @param  rootElement - root DOM element. will be parsed inside the children of this element\n * @return result of parsing\n */\nexport function parseDOM(\n    config: ParserConfig,\n    rootElement?: HTMLElement\n): ParseDomResult {\n    if (config.type === \"string\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            return parentElement.textContent\n        }\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        return targetElement ? targetElement.textContent : null\n    }\n    if (config.type === \"count\") {\n        const parentElement = rootElement || window.document\n        const targetElements = parentElement.querySelectorAll<HTMLElement>(config.selector)\n        return targetElements.length\n    }\n    if (config.type === \"number\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value = targetElement ? targetElement.textContent : null\n        return config.formatter(value, targetElement)\n    }\n\n    if (config.type === \"boolean\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        return Boolean(targetElement)\n    }\n    if (config.type === \"array\") {\n        const parentElement = rootElement || window.document\n        const mathedElems = parentElement.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        if (config.items) {\n            const values = [] as ParseDomResult[]\n            for (const el of mathedElems) {\n                values.push(parseDOM(config.items, el))\n            }\n            return values\n        } else {\n            return [...mathedElems].map((el: HTMLElement) => el.textContent)\n        }\n    }\n    if (config.type === \"object\") {\n        const result = {} as { [key: string]: ParseDomResult }\n        for (const { key, value } of config.keys) {\n            result[key] = parseDOM(value, rootElement)\n        }\n        return result\n    }\n    return null\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype EventHadler<P = any> = (p: P) => any\n\ntype Event = {\n    eventName: string\n    handlers: EventHadler[]\n}\n\n/* Simple EventEmitter */\nexport class EventEmitter {\n    private events: Event[] = []\n\n    private createUnwatcher<P = any>(\n        eventName: string,\n        handler: EventHadler<P>\n    ) {\n        return () => {\n            for (let i = 0; i < this.events.length; i++) {\n                const event = this.events[i]\n                event.handlers = event.handlers.filter(\n                    existingHandler => existingHandler !== handler\n                )\n                if (event.handlers.length) continue\n                this.events.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    public on<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher<P>(eventName, handler)\n\n        const existingEvent = this.events.find(\n            found => found.eventName === eventName\n        )\n        if (existingEvent && existingEvent.handlers.includes(handler)) {\n            return unwatch\n        } else if (existingEvent) {\n            existingEvent.handlers.push(handler)\n        } else {\n            this.events.push({ eventName, handlers: [handler] })\n        }\n        return unwatch\n    }\n\n    public off<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher(eventName, handler)\n        unwatch()\n    }\n\n    public dispatch<P = any>(eventName: string, payload?: P) {\n        const event = this.events.find(event => event.eventName === eventName)\n        if (event) {\n            for (const handler of event.handlers) {\n                handler(payload)\n            }\n        }\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { EventEmitter } from \"./EventEmitter\"\n\nconst MAIN_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\ntype TargetElementDescriptor = {\n    name: string\n    selector: string\n    observerConfig?: MutationObserverInit\n}\n\ntype TargetElementsObserver = {\n    descriptor: TargetElementDescriptor\n    observers: MutationObserver[]\n}\n\nexport const FOUND_EVENT_NAME = \"target-element-found\"\nexport const MUTATED_EVENT_NAME = \"target-element-mutated\"\n\nexport type FoundEvent = {\n    type: typeof FOUND_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    element: HTMLElement\n}\n\nexport type MutatedEvent = {\n    type: typeof MUTATED_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    mutations: MutationRecord[]\n}\n\nexport type ObserveDomEvent = FoundEvent | MutatedEvent\n\nexport type MainObserverCb = (mutations: MutationRecord[]) => void\n\ntype SubscribeCb = (e: ObserveDomEvent) => void\n\nexport class DomObserver extends EventEmitter {\n    private _mainObserver: MutationObserver | null = null\n    private _observedElements: HTMLElement[] = []\n    private _targetElementsObservers: TargetElementsObserver[] = []\n    private _targetElementsDescriptors: TargetElementDescriptor[] = []\n    private _checkTargetSelectorAndObserve(\n        descriptor: TargetElementDescriptor,\n        el: HTMLElement,\n        mutationsList: MutationRecord[],\n    ) {\n        const targetElements = el.matches(descriptor.selector)\n            ? [el]\n            : [...el.querySelectorAll<HTMLElement>(descriptor.selector)]\n\n        if (!targetElements.length) {\n            return\n        }\n\n        this._observeTargetElements(targetElements, descriptor)\n\n        // check if the mutation of the target node is in the mutations list\n        const matchedMutations = this._matchTargetElementMutations(\n            descriptor,\n            mutationsList\n        )\n        if (matchedMutations.length) {\n            this._dispatchMutatedEvent(matchedMutations, descriptor)\n        }\n    }\n    private _matchTargetElementMutations(\n        descriptor: TargetElementDescriptor,\n        mutationsList: MutationRecord[]\n    ) {\n        const matchedMutations = []\n        for (const mutation of mutationsList) {\n            if ((mutation.target as HTMLElement).closest(descriptor.selector)) {\n                matchedMutations.push(mutation)\n            }\n        }\n        return matchedMutations\n    }\n    private _observeTargetElements(\n        elems: HTMLElement[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const observer = new window.MutationObserver(mutations =>\n            this._onTargetElementMutated(mutations, descriptor)\n        )\n        for (const elem of elems) {\n            // already observed\n            if (this._observedElements.includes(elem)) continue\n            this._observedElements.push(elem)\n            const html = elem.innerHTML\n            this._dispatchFoundEvent(descriptor, elem)\n            observer.observe(elem, descriptor.observerConfig)\n        }\n        const existingObserverItem = this._targetElementsObservers.find(\n            found => found.descriptor.name === descriptor.name\n        )\n        if (existingObserverItem) {\n            existingObserverItem.observers.push(observer)\n        } else {\n            this._targetElementsObservers.push({\n                descriptor,\n                observers: [observer],\n            })\n        }\n    }\n    private _onTargetElementMutated(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        this._dispatchMutatedEvent(mutations, descriptor)\n    }\n    private _dispatchMutatedEvent(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const payload: MutatedEvent = {\n            type: MUTATED_EVENT_NAME,\n            descriptor,\n            mutations,\n        }\n        this.dispatch(\"target-element-mutated\", payload)\n    }\n    private _dispatchFoundEvent(\n        descriptor: TargetElementDescriptor,\n        element: HTMLElement\n    ) {\n        const payload: FoundEvent = {\n            type: FOUND_EVENT_NAME,\n            descriptor,\n            element,\n        }\n        this.dispatch(\"target-element-found\", payload)\n    }\n    private _onRootElementMutated = (mutationsList: MutationRecord[]) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type !== \"childList\") continue\n            for (const node of mutation.addedNodes) {\n                if (!(node instanceof window.HTMLElement)) continue\n                for (const descriptor of this._targetElementsDescriptors) {\n                    this._checkTargetSelectorAndObserve(\n                        descriptor,\n                        node,\n                        mutationsList\n                    )\n                }\n            }\n\n            this._clearObservedElementsByMutation(mutation)\n        }\n    }\n    private _clearObservedElementsByMutation(mutation: MutationRecord) {\n        this._observedElements = this._observedElements.filter(\n            (obvservedNode) => {\n                return ![...mutation.removedNodes].includes(obvservedNode)\n            }\n        )\n    }\n    private _clearObservedElementsByDescriptor(\n        descriptor: TargetElementDescriptor\n    ) {\n        this._observedElements = this._observedElements.filter(\n            (observedNode) => {\n                return !observedNode.matches(descriptor.selector)\n            }\n        )\n    }\n    constructor(private _rootElement: HTMLElement = document.body) {\n        super()\n    }\n    get observedElements() {\n        return [...this._observedElements]\n    }\n    public start(cb?: MainObserverCb) {\n        this._mainObserver = new window.MutationObserver(mutations => {\n            this._onRootElementMutated(mutations)\n            if (cb) {\n                cb(mutations)\n            }\n        })\n        this._mainObserver.observe(this._rootElement, MAIN_OBSERVER_CONFIG)\n        return this\n    }\n    public stop() {\n        if (this._mainObserver) {\n            this._mainObserver.disconnect()\n            this._onRootElementMutated(this._mainObserver.takeRecords())\n            this._mainObserver = null\n        }\n        this.stopObservation()\n        return this\n    }\n    public subscribe(cb: SubscribeCb, descriptor?: TargetElementDescriptor) {\n        const handleEvent = (e: ObserveDomEvent) => {\n            if (!descriptor) {\n                cb(e)\n                return\n            }\n            if (descriptor.name === e.descriptor.name) {\n                cb(e)\n            }\n        }\n        this.on<MutatedEvent>(MUTATED_EVENT_NAME, handleEvent)\n        this.on<FoundEvent>(FOUND_EVENT_NAME, handleEvent)\n        return () => {\n            this.off(MUTATED_EVENT_NAME, handleEvent)\n            this.off(FOUND_EVENT_NAME, handleEvent)\n        }\n    }\n    public stopObservation(name?: string) {\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const targetElementObserver = this._targetElementsObservers[i]\n            if (name && targetElementObserver.descriptor.name !== name) continue\n\n            this._clearObservedElementsByDescriptor(\n                targetElementObserver.descriptor\n            )\n\n            for (const mObserver of targetElementObserver.observers) {\n                const unhandledRecords = mObserver.takeRecords()\n                if (unhandledRecords.length) {\n                    this._onTargetElementMutated(\n                        unhandledRecords,\n                        targetElementObserver.descriptor\n                    )\n                }\n                mObserver.disconnect()\n            }\n            this._targetElementsObservers.splice(i, 1)\n            i--\n        }\n        if (!name) {\n            this._targetElementsDescriptors = []\n            return this\n        }\n        const updatedDescriptors = this._targetElementsDescriptors.filter(\n            found => found.name !== name\n        )\n        this._targetElementsDescriptors = updatedDescriptors\n        return this\n    }\n    public observe(descriptor: TargetElementDescriptor) {\n        this._targetElementsDescriptors.push(descriptor)\n        // element already exists\n        const targetElements = [\n            ...this._rootElement.querySelectorAll<HTMLElement>(\n                descriptor.selector\n            ),\n        ]\n        if (targetElements.length) {\n            this._observeTargetElements(targetElements, descriptor)\n        }\n        return this\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { DomObserver, MainObserverCb } from \"./DomObserver\"\nimport { parseDOM, ParserConfig, ParseDomResult } from \"./DomParser\"\n\nexport type DomCollectorTarget = {\n    name: string\n    targetSelector: string\n    guardSelector?: string\n    parseRootEl: string | HTMLElement\n    observeConfig?: MutationObserverInit\n    parseConfig: ParserConfig\n    payload?: any\n    mapResult?: (parsedContent: any) => any\n}\n\ntype DomCollectorResult = {\n    name: string\n    payload?: any\n    parsedContent: any\n}\n\ntype Params = {\n    targets: DomCollectorTarget[]\n    onCollect: (result: DomCollectorResult) => void\n    rootEl?: HTMLElement\n    mainObserverCallback?: MainObserverCb\n}\n\nconst DEFAULT_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\nexport const createDomCollector = ({\n    targets,\n    onCollect,\n    rootEl,\n    mainObserverCallback,\n}: Params) => {\n    const domObserver = new DomObserver(rootEl || document.body)\n    \n    domObserver.start(mainObserverCallback)\n    \n    for (const target of targets) {\n        const { mapResult } = target\n\n        const observeDescriptor = {\n            name: target.name,\n            selector: target.targetSelector,\n            observerConfig: target.observeConfig || DEFAULT_OBSERVER_CONFIG,\n        }\n        domObserver.subscribe((e) => {\n            const { guardSelector } = target\n            if (!guardSelector || document.querySelector(guardSelector)) {\n                const parseRootEl =\n                    typeof target.parseRootEl === \"string\"\n                        ? document.querySelector<HTMLElement>(\n                            target.parseRootEl\n                        )\n                        : target.parseRootEl\n                if (!parseRootEl) {\n                    return\n                }\n                const parsedContent = parseDOM(target.parseConfig, parseRootEl)\n                onCollect({\n                    name: target.name,\n                    payload: target.payload,\n                    parsedContent: mapResult ? mapResult(parsedContent) : parsedContent,\n                })\n            }\n        }, observeDescriptor)\n        domObserver.observe(observeDescriptor)\n    }\n\n    return domObserver\n}\n"],"names":["parseDOM","config","rootElement","type","parentElement","window","document","selector","textContent","targetElement","querySelector","querySelectorAll","length","value","formatter","Boolean","mathedElems","items","values","el","push","map","result","key","keys","EventEmitter","[object Object]","this","eventName","handler","i","events","event","handlers","filter","existingHandler","splice","unwatch","createUnwatcher","existingEvent","find","found","includes","payload","MAIN_OBSERVER_CONFIG","attributes","childList","subtree","characterData","characterDataOldValue","attributeOldValue","DomObserver","_rootElement","body","super","mutationsList","mutation","node","addedNodes","HTMLElement","descriptor","_targetElementsDescriptors","_checkTargetSelectorAndObserve","_clearObservedElementsByMutation","targetElements","matches","_observeTargetElements","matchedMutations","_matchTargetElementMutations","_dispatchMutatedEvent","target","closest","elems","observer","MutationObserver","mutations","_onTargetElementMutated","elem","_observedElements","innerHTML","_dispatchFoundEvent","observe","observerConfig","existingObserverItem","_targetElementsObservers","name","observers","dispatch","element","obvservedNode","removedNodes","observedNode","observedElements","cb","_mainObserver","_onRootElementMutated","disconnect","takeRecords","stopObservation","handleEvent","e","on","off","targetElementObserver","_clearObservedElementsByDescriptor","mObserver","unhandledRecords","updatedDescriptors","DEFAULT_OBSERVER_CONFIG","targets","onCollect","rootEl","mainObserverCallback","domObserver","start","mapResult","observeDescriptor","targetSelector","observeConfig","subscribe","guardSelector","parseRootEl","parsedContent","parseConfig"],"mappings":"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"}