{"version":3,"file":"dom-observer.es.js","sources":["../src/DomParser.ts","../src/EventEmitter.ts","../src/DomObserver.ts","../src/DomCollector.ts"],"sourcesContent":["/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype ParseTarget = \"textContent\" | string\n\ntype ParserConfigObject = {\n    type: \"object\"\n    keys: {\n        key: string\n        value: ParserConfig\n    }[]\n}\n\ntype ParserConfigArray = {\n    type: \"array\"\n    selector: string\n    parseFrom?: ParseTarget\n    items?: ParserConfig\n}\n\ntype ParserConfigString = {\n    type: \"string\"\n    selector?: string\n    parseFrom?: ParseTarget\n    formatter?: (value: string | null, el: HTMLElement | null) => any\n}\n\ntype ParseConfigBoolean = {\n    type: \"boolean\"\n    selector: string\n}\n\ntype ParseConfigCount = {\n    type: \"count\"\n    selector: string\n}\n\ntype ParseConfigNumber = {\n    type: \"number\"\n    selector: string\n    parseFrom?: ParseTarget\n    formatter: (value: string | null, el: HTMLElement | null) => number | null\n}\n\nexport type ParserConfig =\n    | ParserConfigObject\n    | ParserConfigArray\n    | ParserConfigString\n    | ParseConfigBoolean\n    | ParseConfigNumber\n    | ParseConfigCount\n\nexport type ParseDomResult =\n    | string\n    | null\n    | boolean\n    | number\n    | Array<ParseDomResult>\n    | {\n        [key: string]: ParseDomResult\n    }\n\n\nconst parseText = (\n    el: HTMLElement | Document,\n    parseFrom?: ParseTarget\n) => {\n    if (!parseFrom || (parseFrom === \"textContent\")) {\n        return el.textContent\n    }\n    if (typeof parseFrom === \"string\" && el instanceof HTMLElement) {\n        return el.getAttribute(parseFrom)\n    }\n    return null\n}\n\n/**\n * Parse a specific structure from the DOM recursively\n * @param  config - configuration object that describes the type of the resulting object and how to get it from the DOM\n * @param  rootElement - root DOM element. will be parsed inside the children of this element\n * @return result of parsing\n */\nexport function parseDOM(\n    config: ParserConfig,\n    rootElement?: HTMLElement\n): ParseDomResult {\n    if (config.type === \"string\") {\n        const parentElement = rootElement || window.document\n        if (!config.selector) {\n            return parseText(parentElement, config.parseFrom)\n        }\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value =  targetElement\n            ? parseText(targetElement, config.parseFrom)\n            : null\n        return config.formatter ? config.formatter(value, targetElement) : value\n    }\n    if (config.type === \"count\") {\n        const parentElement = rootElement || window.document\n        const targetElements = parentElement.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        return targetElements.length\n    }\n    if (config.type === \"number\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        const value = targetElement\n            ? parseText(targetElement, config.parseFrom) : null\n        return config.formatter(value, targetElement)\n    }\n\n    if (config.type === \"boolean\") {\n        const parentElement = rootElement || window.document\n        const targetElement = parentElement.querySelector<HTMLElement>(\n            config.selector\n        )\n        return Boolean(targetElement)\n    }\n    if (config.type === \"array\") {\n        const parentElement = rootElement || window.document\n        const mathedElems = parentElement.querySelectorAll<HTMLElement>(\n            config.selector\n        )\n        if (config.items) {\n            const values = [] as ParseDomResult[]\n            for (const el of mathedElems) {\n                values.push(parseDOM(config.items, el))\n            }\n            return values\n        } else {\n            return [...mathedElems].map(\n                (el: HTMLElement) => parseText(el, config.parseFrom)\n            )\n        }\n    }\n    if (config.type === \"object\") {\n        const result = {} as { [key: string]: ParseDomResult }\n        for (const { key, value } of config.keys) {\n            result[key] = parseDOM(value, rootElement)\n        }\n        return result\n    }\n    return null\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\ntype EventHadler<P = any> = (p: P) => any\n\ntype Event = {\n    eventName: string\n    handlers: EventHadler[]\n}\n\n/* Simple EventEmitter */\nexport class EventEmitter {\n    private events: Event[] = []\n\n    private createUnwatcher<P = any>(\n        eventName: string,\n        handler: EventHadler<P>\n    ) {\n        return () => {\n            for (let i = 0; i < this.events.length; i++) {\n                const event = this.events[i]\n                event.handlers = event.handlers.filter(\n                    existingHandler => existingHandler !== handler\n                )\n                if (event.handlers.length) continue\n                this.events.splice(i, 1)\n                i--\n            }\n        }\n    }\n\n    public on<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher<P>(eventName, handler)\n\n        const existingEvent = this.events.find(\n            found => found.eventName === eventName\n        )\n        if (existingEvent && existingEvent.handlers.includes(handler)) {\n            return unwatch\n        } else if (existingEvent) {\n            existingEvent.handlers.push(handler)\n        } else {\n            this.events.push({ eventName, handlers: [handler] })\n        }\n        return unwatch\n    }\n\n    public off<P = any>(eventName: string, handler: EventHadler<P>) {\n        const unwatch = this.createUnwatcher(eventName, handler)\n        unwatch()\n    }\n\n    public dispatch<P = any>(eventName: string, payload?: P) {\n        const event = this.events.find(event => event.eventName === eventName)\n        if (event) {\n            for (const handler of event.handlers) {\n                handler(payload)\n            }\n        }\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { EventEmitter } from \"./EventEmitter\"\n\nconst MAIN_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\ntype TargetElementDescriptor = {\n    name: string\n    selector: string\n    observerConfig?: MutationObserverInit\n}\n\ntype TargetElementsObserver = {\n    descriptor: TargetElementDescriptor\n    observers: MutationObserver[]\n}\n\nexport const FOUND_EVENT_NAME = \"target-element-found\"\nexport const MUTATED_EVENT_NAME = \"target-element-mutated\"\n\nexport type FoundEvent = {\n    type: typeof FOUND_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    element: HTMLElement\n}\n\nexport type MutatedEvent = {\n    type: typeof MUTATED_EVENT_NAME\n    descriptor: TargetElementDescriptor\n    mutations: MutationRecord[]\n}\n\nexport type ObserveDomEvent = FoundEvent | MutatedEvent\n\nexport type MainObserverCb = (mutations: MutationRecord[]) => void\n\ntype SubscribeCb = (e: ObserveDomEvent) => void\n\nexport class DomObserver extends EventEmitter {\n    private _mainObserver: MutationObserver | null = null\n    private _observedElements: HTMLElement[] = []\n    private _targetElementsObservers: TargetElementsObserver[] = []\n    private _targetElementsDescriptors: TargetElementDescriptor[] = []\n    private _checkTargetSelectorAndObserve(\n        descriptor: TargetElementDescriptor,\n        el: HTMLElement,\n        mutationsList: MutationRecord[],\n    ) {\n        const targetElements = el.matches(descriptor.selector)\n            ? [el]\n            : [...el.querySelectorAll<HTMLElement>(descriptor.selector)]\n\n        if (!targetElements.length) {\n            return\n        }\n\n        this._observeTargetElements(targetElements, descriptor)\n\n        // check if the mutation of the target node is in the mutations list\n        const matchedMutations = this._matchTargetElementMutations(\n            descriptor,\n            mutationsList\n        )\n        if (matchedMutations.length) {\n            this._dispatchMutatedEvent(matchedMutations, descriptor)\n        }\n    }\n    private _matchTargetElementMutations(\n        descriptor: TargetElementDescriptor,\n        mutationsList: MutationRecord[]\n    ) {\n        const matchedMutations = []\n        for (const mutation of mutationsList) {\n            if ((mutation.target as HTMLElement).closest(descriptor.selector)) {\n                matchedMutations.push(mutation)\n            }\n        }\n        return matchedMutations\n    }\n    private _observeTargetElements(\n        elems: HTMLElement[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const observer = new window.MutationObserver(mutations =>\n            this._onTargetElementMutated(mutations, descriptor)\n        )\n        for (const elem of elems) {\n            // already observed\n            if (this._observedElements.includes(elem)) continue\n            this._observedElements.push(elem)\n            const html = elem.innerHTML\n            this._dispatchFoundEvent(descriptor, elem)\n            observer.observe(elem, descriptor.observerConfig)\n        }\n        const existingObserverItem = this._targetElementsObservers.find(\n            found => found.descriptor.name === descriptor.name\n        )\n        if (existingObserverItem) {\n            existingObserverItem.observers.push(observer)\n        } else {\n            this._targetElementsObservers.push({\n                descriptor,\n                observers: [observer],\n            })\n        }\n    }\n    private _onTargetElementMutated(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        this._dispatchMutatedEvent(mutations, descriptor)\n    }\n    private _dispatchMutatedEvent(\n        mutations: MutationRecord[],\n        descriptor: TargetElementDescriptor\n    ) {\n        const payload: MutatedEvent = {\n            type: MUTATED_EVENT_NAME,\n            descriptor,\n            mutations,\n        }\n        this.dispatch(\"target-element-mutated\", payload)\n    }\n    private _dispatchFoundEvent(\n        descriptor: TargetElementDescriptor,\n        element: HTMLElement\n    ) {\n        const payload: FoundEvent = {\n            type: FOUND_EVENT_NAME,\n            descriptor,\n            element,\n        }\n        this.dispatch(\"target-element-found\", payload)\n    }\n    private _onRootElementMutated = (mutationsList: MutationRecord[]) => {\n        for (const mutation of mutationsList) {\n            if (mutation.type !== \"childList\") continue\n            for (const node of mutation.addedNodes) {\n                if (!(node instanceof window.HTMLElement)) continue\n                for (const descriptor of this._targetElementsDescriptors) {\n                    this._checkTargetSelectorAndObserve(\n                        descriptor,\n                        node,\n                        mutationsList\n                    )\n                }\n            }\n\n            this._clearObservedElementsByMutation(mutation)\n        }\n    }\n    private _clearObservedElementsByMutation(mutation: MutationRecord) {\n        this._observedElements = this._observedElements.filter(\n            (obvservedNode) => {\n                return ![...mutation.removedNodes].includes(obvservedNode)\n            }\n        )\n    }\n    private _clearObservedElementsByDescriptor(\n        descriptor: TargetElementDescriptor\n    ) {\n        this._observedElements = this._observedElements.filter(\n            (observedNode) => {\n                return !observedNode.matches(descriptor.selector)\n            }\n        )\n    }\n    constructor(private _rootElement: HTMLElement = document.body) {\n        super()\n    }\n    get observedElements() {\n        return [...this._observedElements]\n    }\n    public start(cb?: MainObserverCb) {\n        this._mainObserver = new window.MutationObserver(mutations => {\n            this._onRootElementMutated(mutations)\n            if (cb) {\n                cb(mutations)\n            }\n        })\n        this._mainObserver.observe(this._rootElement, MAIN_OBSERVER_CONFIG)\n        return this\n    }\n    public stop() {\n        if (this._mainObserver) {\n            this._mainObserver.disconnect()\n            this._onRootElementMutated(this._mainObserver.takeRecords())\n            this._mainObserver = null\n        }\n        this.stopObservation()\n        return this\n    }\n    public subscribe(cb: SubscribeCb, descriptor?: TargetElementDescriptor) {\n        const handleEvent = (e: ObserveDomEvent) => {\n            if (!descriptor) {\n                cb(e)\n                return\n            }\n            if (descriptor.name === e.descriptor.name) {\n                cb(e)\n            }\n        }\n        this.on<MutatedEvent>(MUTATED_EVENT_NAME, handleEvent)\n        this.on<FoundEvent>(FOUND_EVENT_NAME, handleEvent)\n        return () => {\n            this.off(MUTATED_EVENT_NAME, handleEvent)\n            this.off(FOUND_EVENT_NAME, handleEvent)\n        }\n    }\n    public stopObservation(name?: string) {\n        for (let i = 0; i < this._targetElementsObservers.length; i++) {\n            const targetElementObserver = this._targetElementsObservers[i]\n            if (name && targetElementObserver.descriptor.name !== name) continue\n\n            this._clearObservedElementsByDescriptor(\n                targetElementObserver.descriptor\n            )\n\n            for (const mObserver of targetElementObserver.observers) {\n                const unhandledRecords = mObserver.takeRecords()\n                if (unhandledRecords.length) {\n                    this._onTargetElementMutated(\n                        unhandledRecords,\n                        targetElementObserver.descriptor\n                    )\n                }\n                mObserver.disconnect()\n            }\n            this._targetElementsObservers.splice(i, 1)\n            i--\n        }\n        if (!name) {\n            this._targetElementsDescriptors = []\n            return this\n        }\n        const updatedDescriptors = this._targetElementsDescriptors.filter(\n            found => found.name !== name\n        )\n        this._targetElementsDescriptors = updatedDescriptors\n        return this\n    }\n    public observe(descriptor: TargetElementDescriptor) {\n        this._targetElementsDescriptors.push(descriptor)\n        // element already exists\n        const targetElements = [\n            ...this._rootElement.querySelectorAll<HTMLElement>(\n                descriptor.selector\n            ),\n        ]\n        if (targetElements.length) {\n            this._observeTargetElements(targetElements, descriptor)\n        }\n        return this\n    }\n}\n","/**\n * By Alexey Avramenko and Retentioneering Team \n * Copyright (C) 2020 Maxim Godzi, Anatoly Zaytsev, Retentioneering Team\n * This Source Code Form is subject to the terms of the Retentioneering Software Non-Exclusive, Non-Commercial Use License (License)\n * By using, sharing or editing this code you agree with the License terms and conditions. \n * You can obtain License text at https://github.com/retentioneering/retentioneering-dom-observer/blob/master/LICENSE.md\n */\nimport { DomObserver, MainObserverCb } from \"./DomObserver\"\nimport { parseDOM, ParserConfig, ParseDomResult } from \"./DomParser\"\n\nexport type DomCollectorTarget = {\n    name: string\n    targetSelector: string\n    guardSelector?: string\n    parseRootEl: string | HTMLElement\n    observeConfig?: MutationObserverInit\n    parseConfig: ParserConfig\n    payload?: any\n    mapResult?: (parsedContent: any) => any\n}\n\ntype DomCollectorResult = {\n    name: string\n    payload?: any\n    parsedContent: any\n}\n\ntype Params = {\n    targets: DomCollectorTarget[]\n    onCollect: (result: DomCollectorResult) => void\n    rootEl?: HTMLElement\n    mainObserverCallback?: MainObserverCb\n}\n\nconst DEFAULT_OBSERVER_CONFIG = {\n    attributes: false,\n    childList: true,\n    subtree: true,\n    characterData: false,\n    characterDataOldValue: false,\n    attributeOldValue: false,\n}\n\nexport const createDomCollector = ({\n    targets,\n    onCollect,\n    rootEl,\n    mainObserverCallback,\n}: Params) => {\n    const domObserver = new DomObserver(rootEl || document.body)\n    \n    domObserver.start(mainObserverCallback)\n    \n    for (const target of targets) {\n        const { mapResult } = target\n\n        const observeDescriptor = {\n            name: target.name,\n            selector: target.targetSelector,\n            observerConfig: target.observeConfig || DEFAULT_OBSERVER_CONFIG,\n        }\n        domObserver.subscribe((e) => {\n            const { guardSelector } = target\n            if (!guardSelector || document.querySelector(guardSelector)) {\n                const parseRootEl =\n                    typeof target.parseRootEl === \"string\"\n                        ? document.querySelector<HTMLElement>(\n                            target.parseRootEl\n                        )\n                        : target.parseRootEl\n                if (!parseRootEl) {\n                    return\n                }\n                const parsedContent = parseDOM(target.parseConfig, parseRootEl)\n                onCollect({\n                    name: target.name,\n                    payload: target.payload,\n                    parsedContent: mapResult ? mapResult(parsedContent) : parsedContent,\n                })\n            }\n        }, observeDescriptor)\n        domObserver.observe(observeDescriptor)\n    }\n\n    return domObserver\n}\n"],"names":["parseText","el","parseFrom","HTMLElement","getAttribute","textContent","parseDOM","config","rootElement","type","parentElement","window","document","selector","targetElement","querySelector","value","formatter","querySelectorAll","length","Boolean","mathedElems","items","values","push","map","result","key","keys","EventEmitter","[object Object]","this","eventName","handler","i","events","event","handlers","filter","existingHandler","splice","unwatch","createUnwatcher","existingEvent","find","found","includes","payload","MAIN_OBSERVER_CONFIG","attributes","childList","subtree","characterData","characterDataOldValue","attributeOldValue","FOUND_EVENT_NAME","MUTATED_EVENT_NAME","DomObserver","_rootElement","body","super","mutationsList","mutation","node","addedNodes","descriptor","_targetElementsDescriptors","_checkTargetSelectorAndObserve","_clearObservedElementsByMutation","targetElements","matches","_observeTargetElements","matchedMutations","_matchTargetElementMutations","_dispatchMutatedEvent","target","closest","elems","observer","MutationObserver","mutations","_onTargetElementMutated","elem","_observedElements","innerHTML","_dispatchFoundEvent","observe","observerConfig","existingObserverItem","_targetElementsObservers","name","observers","dispatch","element","obvservedNode","removedNodes","observedNode","observedElements","cb","_mainObserver","_onRootElementMutated","disconnect","takeRecords","stopObservation","handleEvent","e","on","off","targetElementObserver","_clearObservedElementsByDescriptor","mObserver","unhandledRecords","updatedDescriptors","DEFAULT_OBSERVER_CONFIG","createDomCollector","targets","onCollect","rootEl","mainObserverCallback","domObserver","start","mapResult","observeDescriptor","targetSelector","observeConfig","subscribe","guardSelector","parseRootEl","parsedContent","parseConfig"],"mappings":"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"}